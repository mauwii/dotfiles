#!/usr/bin/env sh
# shellcheck shell=sh source=.functions

# add shell functions
if [ -r "${HOME}/.functions" ] && [ "${DOT_FUNCTIONS}" != "true" ]; then
    # shellcheck source=.functions
    . "${HOME}/.functions"
fi

debuglog "loading .aliases"

# Recursively delete `.DS_Store` files
alias cleanup="find . -name '*.DS_Store' -type f -ls -delete"
# remove broken symlinks
alias clsym="find -L . -name . -o -type d -prune -o -type l -exec rm {} +"

# use exa as modern ls-replacement if available
if validate_command exa; then
    exa --git >/dev/null 2>&1 && exa_git="true"
    # shellcheck disable=SC2139
    alias ls="exa --icons --group-directories-first ${exa_git:+--git} --accessed --modified --created"
elif [ "$(uname -s)" = "Darwin" ]; then
    alias ls='ls -G'
else
    alias ls='ls --color=auto --group-directories-first'
fi

# ls aliases
alias l='ls -a -h'
alias ll='l -l -g'
alias lll='ll -@'
alias lr='ls -R'
alias llr='lr -l'

# replace cat with bat, but disable paging to make it behave like cat
if validate_command batcat && ! validate_command bat; then
    alias bat='$(which batcat)'
    debuglog ".aliases: batcat aliased to bat"
fi
if validate_command bat; then
    alias cat="bat --paging=never"
    debuglog ".aliases: cat aliased to bat without pager"
fi

# dotfiles management
if [ -d "${HOME}/.cfg" ] && validate_command git; then
    alias config='git --bare --git-dir="${HOME}/.cfg/" --work-tree="${HOME}"'
    debuglog ".aliases: dotfiles management enabled"
fi
if validate_command config; then
    # link all files to ~/.dotfiles to open in code
    link_dotfiles() {
        cd "${HOME}" || return 1
        for file in $(config ls-tree --full-tree -r --name-only HEAD); do
            # skip .dotfiles folder
            if echo "${file}" | grep -q ".dotfiles"; then
                continue
            fi
            _path="${HOME}/.dotfiles/${file}"
            # clean broken symlinks
            if [ -d "${file%/*}" ]; then
                if [ -d "${_path%/*}" ]; then
                    (cd "${_path%/*}" && clsym)
                else
                    mkdir -p "${_path%/*}"
                fi
            fi
            # create symlink
            ln -sf "${HOME}/${file}" "${_path}"
        done
    }
    # link dotfiles to ~/.dotfiles and open in code
    if validate_command code; then
        alias dotfiles='link_dotfiles && code "${HOME}/.dotfiles"'
    fi
fi

# Copy public SSH Key
if validate_command pbcopy && [ -r "${HOME}/.ssh/id_ed25519.pub" ]; then
    alias pubkey='pbcopy < "${HOME}/.ssh/id_ed25519.pub"'
fi

# dump Brewfile
if [ -n "${HOMEBREW_BUNDLE_FILE}" ]; then
    alias dump-brewfile='brew bundle dump --file="${HOMEBREW_BUNDLE_FILE}" --force --formula --casks --vscode --taps'
fi

# install or match Brewfile (match removes everything whats not in the Brewfile)
if [ -f "${HOMEBREW_BUNDLE_FILE}" ]; then
    alias install-brewfile='brew bundle install --file="${HOMEBREW_BUNDLE_FILE}"'
    alias match-brewfile='brew bundle --force cleanup --file="${HOMEBREW_BUNDLE_FILE}"'
fi

# add getidf alias if ~/esp/esp-idf exists
IDF_PATH="${HOME}/esp/esp-idf"
if [ -f "${IDF_PATH}/export.sh" ]; then
    export ESPIDF="${IDF_PATH}"
    alias getidf='. ${ESPIDF}/export.sh'
else
    unset IDF_PATH
fi

# register-python-argcomplete
if validate_command register-python-argcomplete3; then
    alias register-python-argcomplete='register-python-argcomplete3'
fi
