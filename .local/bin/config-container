#!/usr/bin/env bash
# shellcheck shell=bash disable=SC2207

# completion partially working with: `compdef _gnu_generic config-container`

## initialize variables and set defaults

# enable output of debug messages
debug=${DEBUG:-false}
# path to the dotfiles (bare)repo
dotfilesdir="$HOME"
# commands to mount dotfiles
dockermounts=()
# home directory in the container
dockerhome="/root"
# workdir in the container
workdir="$dockerhome"
# directory to mount the dotfiles in the container
dockermountdir="/mnt/dotfiles"
# container image to use
image="alpine:3.18"
# default shell in the container
shell="bash"
# packages to install
pkgs=()
# command to install packages
installcmd=()

# small function to print log messages if $DEBUG is true
# find infos about how to format in the manpage of printf
debuglog() {
    if [ "${debug}" = "true" ]; then
        # shellcheck disable=SC2059
        _logmsg=$(printf "$@")
        printf "[%s] %s\n" "$(date "+%T")" "${_logmsg}"
    fi
}

helpmsg() {
    # format help message lines:
    #   $1: long option
    #   $2: short option
    #   $3: description
    #   $4: current value (optional)
    printhelp() {
        printf "  %-13s %3s  %-35s %-10s\n" "${1}" "${2}" "${3}" "${4:-}"
    }
    printf "\nUsage:\t%s [options]\n" "${0##*/}"
    printf "\nOptions:\n\n"
    printhelp "--dotfilesdir" "-p" "Path to your dotfiles" "${dotfilesdir}"
    printhelp "--image" "-i" "Container image to use" "${image}"
    printhelp "--shell" "-s" "Shell to use in the container" "${shell}"
    printhelp "--no-pkgs" "-0" "Switch to install without pkgs"
    printhelp "--debug" "-d" "Switch to enable debug messages"
    printhelp "--help" "-h" "Print this help message"
}

# read arguments which where passed to the script
for arg in "$@"; do
    case "$arg" in
        -h | --help)
            printf "\nLittle helper to test and debug the dotfiles in different Distros\n"
            helpmsg
            exit 0
            ;;
        -p | --dotfilesdir*)
            [ "${_dotfilesdir:-unset}" != "unset" ] \
                && echo "error: dotfiles can only be set once" \
                && exit 1
            if [[ "${arg}" != *"="* ]]; then
                shift
                _dotfilesdir="$1"
                return
            else
                _dotfilesdir="${arg#*=}"
            fi
            if [ -d "$_dotfilesdir" ]; then
                ## _dotfilesdir="$(realpath -e $_dotfilesdir)"
                dotfilesdir="$_dotfilesdir"
            else
                printf "error: %s is not a directory" "${_dotfilesdir}"
                exit 1
            fi
            ;;
        -s | --shell*)
            [ "${_shell:-unset}" != "unset" ] \
                && echo "error: shell can only be set once" \
                && exit 1
            if [[ "${arg}" != *"="* ]]; then
                shift
                _shell="$1"
                skip="true"
            else
                _shell="${arg#*=}"
            fi
            shell="$_shell"
            continue
            ;;
        -i | --image*)
            [ "${_image:-unset}" != "unset" ] \
                && echo "error: image can only be set once" \
                && exit 1
            if [[ "${arg}" != *"="* ]]; then
                shift
                _image="$1"
                skip="true"
            else
                _image="${arg#*=}"
            fi
            [ -z "$_image" ] \
                && echo "error: image can not be empty" \
                && exit 1
            [ "${_image:0:1}" = "-" ] \
                && echo "error: image can not start with a dash" \
                && exit 1
            [ "${_image:0:1}" = "/" ] \
                && echo "error: image can not start with a slash" \
                && exit 1
            [ "${_image:0:1}" = ":" ] \
                && echo "error: image can not start with a colon" \
                && exit 1
            [ "${_image: -1}" = ":" ] \
                && echo "error: image can not end with a colon" \
                && exit 1
            [ "${_image: -1}" = "/" ] \
                && echo "error: image can not end with a slash" \
                && exit 1
            [ "${_image: -1}" = "-" ] \
                && echo "error: image can not end with a dash" \
                && exit 1
            [ "${_image: -1}" = "." ] \
                && echo "error: image can not end with a dot" \
                && exit 1
            [ "${_image: -1}" = "_" ] \
                && echo "error: image can not end with an underscore" \
                && exit 1
            [ "${_image: -1}" = "@" ] \
                && echo "error: image can not end with an at sign" \
                && exit 1
            [ "${_image: -1}" = "!" ] \
                && echo "error: image can not end with an exclamation mark" \
                && exit 1
            [ "${_image: -1}" = "#" ] \
                && echo "error: image can not end with a hash" \
                && exit 1
            [ "${_image: -1}" = "$" ] \
                && echo "error: image can not end with a dollar sign" \
                && exit 1
            [ "${_image: -1}" = "%" ] \
                && echo "error: image can not end with a percent sign" \
                && exit 1
            [ "${_image: -1}" = "^" ] \
                && echo "error: image can not end with a caret" \
                && exit 1
            image="$_image"
            continue
            ;;
        -d | --debug)
            # enable debug messages
            debug="true"
            ;;
        -0 | --no-pkgs)
            # don't install packages
            no_pkgs="true"
            ;;
        *)
            if [ "$skip" = "true" ]; then
                unset skip
            else
                printf "error: unknown argument: %s\n" "$arg"
                helpmsg
                exit 1
            fi
            ;;
    esac
    shift
done

# set shell and installcmd based on image
case "${image}" in
    */alpine:* | */alpine | alpine:* | alpine)
        installcmd=(apk --no-cache add)
        pkgs=(bat bash direnv exa nano pandoc starship w3m w3m-image zsh)
        ;;
    */debian:* | */debian | debian:* | debian | */ubuntu:* | */ubuntu | ubuntu:* | ubuntu)
        installcmd=(apt-get update \&\& apt-get install -y --no-install-recommends)
        pkgs=(bat direnv exa nano pandoc w3m w3m-img)
        ;;
esac

# unset installcmd and pkgs if no_pkgs is set
if [ "${no_pkgs}" == "true" ]; then
    unset pkgs
    debuglog "no packages will be installed"
fi

# set container cmd
inst=("${pkgs:+${installcmd[@]} ${pkgs[@]} &&}")
container_cmd=(
    "${inst[@]}" sh "${dockermountdir}/.dotfiles/setup_local.sh" \&\& "${shell}" -l
)

# debug output
debuglog "dotfilesdir set to: %s" "${dotfilesdir}"
debuglog "shell set to: %s" "${shell}"
debuglog "image is set to: %s" "${image}"
debuglog "container cmd set to: %s" "${container_cmd[*]}"
debuglog "dockermountdir is set to: %s" "${dockermountdir}"

# function to list all files from the bare repo
getdotfiles() {
    /usr/bin/git \
        --git-dir="${HOME}"/.cfg \
        --work-tree="${HOME}" \
        ls-tree \
        --full-tree -r \
        --name-only HEAD
}

# create dockermount parameter for each dotfile
for dotfile in $(getdotfiles); do
    _localfile="${dotfilesdir}/$dotfile"
    _dockerfile="${dockermountdir}/$dotfile"
    if [[ -f "${_localfile}" ]]; then
        dockermounts+=(-v "${_localfile}":"${_dockerfile}")
    fi
done

# execute container interactive in pseudo tty
debuglog "executing container"
docker run \
    --rm \
    --interactive \
    --tty \
    --workdir="${workdir}" \
    "${dockermounts[@]}" \
    -e DEBIAN_FRONTEND=noninteractive \
    -e "DEBUG=$debug" \
    --name dotfiles \
    --hostname dotfiles \
    "${image}" \
    sh -c "${container_cmd[*]}"
