#!/bin/bash

# small function to print log messages if $DEBUG is true
# for info how to format check man printf
debuglog() {
    if [ "${DEBUG}" = true ]; then
        printf -v _logmsg "$@"
        printf "%s: %s" "$(date "+%T")" "${_logmsg}"
    fi
}

# I wanted to learn how to use case/shift, so I wrote this script which
# makes debugging the dotfiles in different Distros a bit more comfy.

# initialize variables
DEBUG=false
workdir=/root
shell=""
installcmd=()
pkgs=()

# read arguments
for arg in "$@"; do
    case "${arg[@]}" in
        -h | --help)
            printf "\nUsage:\t%s [Options]\n" "${0##*/}"
            printf "\nLittle helper to test and debug the dotfiles in different Distros\n"
            printf "\nOptions:\n\n"
            printf "  -p, --dotfiles <path>\t\tPath to your dotfiles repo\t~/git/mauwii/dotfiles\n"
            printf "  -i, --image <image:tag>\tContainer image to use\t\tdebian:bookworm\n"
            printf "  -0, --no-pkgs\t\t\tswitch to install without pkgs\n"
            printf "  -d, --debug\t\t\tswitch to enable debug messages\n"
            exit 0
            ;;
        -p | --dotfiles*)
            [ "${dotfiles:-unset}" != "unset" ] \
                && echo "error: dotfiles can only be set once" \
                && exit 1
            if [[ "${arg}" != *"="* ]]; then
                shift
                dotfiles="$1"
                return
            else
                dotfiles="${arg#*=}"
            fi
            export dotfiles
            ;;
        -i | --image*)
            [ "${image:-unset}" != "unset" ] \
                && echo "error: image can only be set once" \
                && exit 1
            if [[ "${arg}" != *"="* ]]; then
                shift
                [ -z "$1" ] \
                    && echo "error: image can not be empty" \
                    && exit 1
                [ "${1:0:1}" = "-" ] \
                    && echo "error: image can not start with a dash" \
                    && exit 1
                [ "${1:0:1}" = "/" ] \
                    && echo "error: image can not start with a slash" \
                    && exit 1
                [ "${1:0:1}" = ":" ] \
                    && echo "error: image can not start with a colon" \
                    && exit 1
                [ "${1: -1}" = ":" ] \
                    && echo "error: image can not end with a colon" \
                    && exit 1
                [ "${1: -1}" = "/" ] \
                    && echo "error: image can not end with a slash" \
                    && exit 1
                [ "${1: -1}" = "-" ] \
                    && echo "error: image can not end with a dash" \
                    && exit 1
                [ "${1: -1}" = "." ] \
                    && echo "error: image can not end with a dot" \
                    && exit 1
                [ "${1: -1}" = "_" ] \
                    && echo "error: image can not end with an underscore" \
                    && exit 1
                [ "${1: -1}" = "@" ] \
                    && echo "error: image can not end with an at sign" \
                    && exit 1
                [ "${1: -1}" = "!" ] \
                    && echo "error: image can not end with an exclamation mark" \
                    && exit 1
                [ "${1: -1}" = "#" ] \
                    && echo "error: image can not end with a hash" \
                    && exit 1
                [ "${1: -1}" = "$" ] \
                    && echo "error: image can not end with a dollar sign" \
                    && exit 1
                [ "${1: -1}" = "%" ] \
                    && echo "error: image can not end with a percent sign" \
                    && exit 1
                [ "${1: -1}" = "^" ] \
                    && echo "error: image can not end with a caret" \
                    && exit 1
                image="$1"
            else
                image="${arg#*=}"
            fi
            export image
            ;;
        -d | --debug)
            export DEBUG=true
            ;;
        -0 | --no-pkgs)
            export no_pkgs=true
            ;;
        *)
            shift
            [[ "$arg" = "$1" ]] \
                && printf "error: unknown argument: %s\n" "$arg" \
                && exit 1
            ;;
    esac
    shift
done

# set dotfiles to default if not set
export dotfiles=${dotfiles:-$HOME/git/mauwii/dotfiles}
debuglog "dotfiles set to: %s\n" "${dotfiles}"

# set image to default if not set
export image="${image:-alpine:3}"

# set shell and installcmd based on image
case "${image}" in
    */alpine:* | */alpine | alpine:* | alpine)
        shell="bash"
        installcmd=(apk update \&\& apk add --no-cache)
        pkgs=(bat bash direnv exa nano pandoc starship w3m w3m-image)
        ;;
    */ubuntu:* | */ubuntu | ubuntu:* | ubuntu)
        shell="bash"
        installcmd=(apt-get update \&\& apt-get install -y --no-install-recommends)
        pkgs=(bat direnv exa nano pandoc w3m w3m-img)
        ;;
    */debian:* | */debian | debian:* | debian)
        shell="bash"
        installcmd=(apt-get update \&\& apt-get install -y --no-install-recommends)
        pkgs=(bat direnv exa nano pandoc w3m w3m-img)
        ;;
    *)
        printf "couldn't detect distro, will try to install %s without packages\n" "${image}"
        no_img=true
        ;;
esac

[[ "${no_img}" != true ]] && debuglog "image is set to: %s\n" "${image}"

# unset installcmd and pkgs if no_pkgs is set
if [ "$no_pkgs" == true ]; then
    pkgs=()
    installcmd=()
    debuglog "no packages will be installed\n"
fi

# set container cmd
container_cmd=(
    "${installcmd[@]}" "${pkgs[@]}" ${pkgs:+&&} "${shell}" dotfiles/.dotfiles/setup_local.sh \&\& "${shell}" -l
)
debuglog "container cmd set to:\n%s\n" "${container_cmd[*]}"

# execute container interactive in pseudo tty
debuglog "executing container\n"
docker run \
    --rm \
    --interactive \
    --tty \
    --workdir="${workdir}" \
    -v "${dotfiles}:/root/dotfiles" \
    -e DEBIAN_FRONTEND=noninteractive \
    -e "DEBUG=$DEBUG" \
    --name dotfiles \
    "${image:-debian:bookworm}" \
    sh -c "${container_cmd[*]}"
